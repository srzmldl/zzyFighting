
* Review
** dfs sequence for preparation.
   [[http://main.edu.pl/en/archive/oi/14/meg][POI2007meg]]
   
   讲dfs序性质。然后思考题目。
   - 解法一：区间修改，打标记
   - 解法二：单点修改，无标记。巧用时间戳，前缀和。
   通过这两种方法，深入理解dfs序列。并且熟练使用线段树标记。

** max flow min cost Review
   回顾。为下一题证明做准备。向老师口述自己的理解。

** Game(ShangHai Metropolitan Programming Contest)
   [[http://acm.hdu.edu.cn/showproblem.php?pid=5242][HDU5242]]
   - 结合前两题的基础，层层深入。
   - 利用dfs序列性质，用费用流证明结论，每次选最远的叶子即可。
   - 最后用线段树打标记实现，复杂度为nlogn。
   - 复习张老师教授内容，并加深理解。
   - 代码带回的是打印版。

** exercise
  [[https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1939][白书P201 例题9]]
  [[http://acm.hust.edu.cn/vjudge/problem/viewProblem.action?id=18697][白书P207例题10]]
  

* cpp

** 基础
   参见首页大纲。
   
** 叉姐脑洞题，代码简单。留做现场练习，看代码.
   主要题目选自nhb的ppt。
   
   - [[http://acm.timus.ru/problem.aspx?space=1&num=1979][ural1979]] 简单构造。相对点
   - [[http://codeforces.com/problemset/problem/226/D][CF226D]] 
     - 正确分析复杂度，从全局看,每次整体和加2
     - 翻两次等于没有翻（经常用的结论）
   - [[http://codeforces.com/problemset/problem/468/C][CF468C]]
     - 注意越界问题
     - 1~1e18数位和求法45*18*1e18/10
     - l=1,r=1e18,l，r每次加1,整个数位和加1.


* Bipartite graph
** hungary算法
** 概念（并不需要完全记住，有印像，方便交流即可）
   - 最小点覆盖：最少的点覆盖所有边
   - 最大独立集：最多的点，两两不相邻
   - 最大团：最多的点，任意两点相邻
   - 最大边独立集（匹配）：最多的边，任意两边不相邻
   - 最小点支配集：最少的点，支配所有点
   - 最小边支配集：最少的边，支配所有边
   - 最小路径覆盖：最少的不相交的简单路径覆盖所有点

** 二分图判定
  看起来简单粗暴，常常被忽略。
  - 能否黑白染色
  - 是否有奇环
  通常需要记住一些常见的NPC问题，如果问题转化成这些问题。
那么很有可能这就是二分图。如果不是，能做出来的人一定得可以轰动全球。

** 图论常见NP问题
  概念中的问题（最小路径覆盖除外），染色等都是。如果转化成这种问题，
一定好好观察是否是二分图。马上就会有妙用。

** 二分图性质

*** 最大独立集
    等于顶点数减去最大匹配：最大匹配中点全部去掉，剩余的点为独立集。
此时共|V|-2|M|个点。接着从匹配边取一边加入独立集（这两个点不可能同时与非匹配点相邻，否则可以增广）。（再用抽屉原理证明这是最大的）


*** 最大团：补图的最大独立集
*** 最小点覆盖
    最大匹配。方案：见白书。证明，反证易得。
*** 最小路径覆盖所有点
**** DAG最小不相交路径覆盖.
    - 把原图中的每个点V拆成Vx和Vy，如果有一条有向边A->B，那么就加边Ax-By。
     这样就得到了一个二分图，最小路径覆盖=原图的节点数-新图最大匹配。
    - 证明:一开始每个点都独立的为一条路径，总共有n条不相交路径。
我们每次在二分图里加一条边就相当于把两条路径合成了一条路径，因为路径之间不能有公共点，所以加的边之间也不能有公共点，这就是匹配的定义。所以有：最小路径覆盖=原图的节点数-新图最大匹配。

**** 有向无环图最小可相交路径覆盖
    -  先用floyd求出原图的传递闭包，即如果a到b有路，
     那么就加边a->b。然后就转化成了最小不相交路径覆盖问题。 

*** KM最优匹配
*** 例题
    白书UVA11419, LA3415, LA3126,LA4043,uva11383 找对应题号提交即可。
[[http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66131#overviewirtual][vitual judge]]

[[http://hihocoder.com/problemset/problem/1158][微软编程之美复赛]]


*** wait
lydsy 1076
